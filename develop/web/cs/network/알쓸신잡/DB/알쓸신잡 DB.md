# 멀티 인덱싱

- 멀티 인덱싱이란 무엇인가? → 여러 컬럼을 하나의 인덱스로
- 사용처와 효과는? → 특정 쿼리를 대상으로 해당 쿼리의 조건에 해당하는 컬럼들을 하나의 인덱스로 묶어 인덱스 효율을 더 높임(인덱스를 여러번 탐)
- 멀티 인덱싱은 카디널리티가 높은 컬럼부터 낮은 컬럼순으로 인덱싱해야 효율적(순차적으로 탄다)

---

# Join

- 한 DB 내 여러 테이블의 레코드를 조합하여 하나의 열로 표현

## inner join

- 양쪽 모두에 값이 있는 레코드만을 출력
- 묵시적 조인은 inner join으로 수행된다

## outer join

- 다른 한쪽에 값이 없어도 출력

## cross join

- 조인되는 두 테이블에서 곱집합(카테시안 곱, A*B)을 반환, 그래서 카테시안 조인이라고도 한다
- 두번째 테이블로부터 각행+첫번째 테이블에서 각행이 결합된 열을 만드는것
- m행의 테이블과 n행의 테이블이 교치조인될시 m * n행의 결과가 나온다

## self join

- 한 테이블에서 자기 자신에 조인을 거는것

## join시 유의 사항

- 쿼리에 따라 성능이 크게 좌우되므로, 질의 수행을 명확히 하고 비효율적인 내용을 제거해야함
- 조인 조건이 명확해야함, 그렇지 않을 경우 의도치 않은 cross join이 발생할 수 있음
- 조인 대상의 집합을 최소화
- 인덱스를 적극 활용할 것

---

# SQL Injection

---

# Index

- 자주 조회되는 컬럼에 대한 Index table을 따로 만들어, 해당하는 내용에 대한 값들은 Index table에서 조회해오는것
- 따라서 조회 연산에 대한 성능을 올릴수 있게 되며, 조회가 아닌 삽입, 수정, 삭제는 성능이 떨어질 수도 있다.
- where에 포함된 값을 index table에서 검색하고, 해당 값의 pk를 획득한 뒤, 그 pk를 이용해 원본 테이블에서 값을 조회하는 형태

## 주의 사항

- 따로 테이블로 관리 되므로 자원을 소모한다. 때문에 무분별한 인덱스는 성능 저하를 미칠 수 있다
- 인덱스는 바이너리 트리를 사용하므로, 기본 정렬이 되어있다. 때문에 잦은 데이터의 변경은 index table의 변경과 정렬에 드는 오버헤드가 발생하여 성능이 저하될 수 있다
    - insert: 테이블은 입력순서이지만, index table은 정렬 후 저장함
    - delete: 테이블은 삭제되지만, index table에는 값이 남아있어 쿼리 수행 성능 저하
    - update: index table은 update가 없으므로 insert&delete 두번 수행하므로 부하 발생
- 데이터의 중복이 높은(카디널리티가 낮은) 컬럼은 인덱스로 만들어도 소용이 없다 (e.g. yes or no, 남or여)
- 멀티 인덱싱은 카디널리티가 높은 컬럼부터 낮은 컬럼순으로 인덱싱해야 효율적(순차적으로 탄다)

---

# Statement, PrepareStatement

---

# RDBMS, NoSQL

---

# ORM

---

# JDBC

---

# 분산 락

---

# Optimizer

---

# Replication

---

# Partitioning

- 대용량 DB를 쪼개어 관리하는것(DB의 분산처리)
- 파티셔닝 적용해도 DB에 접근하는 어플리케이션은 인식하지 못한다
- 특정 DML과 Query성능을 향상시킨다
- 대용량 DB WRITE 환경에서 효율적
- 풀스캔시 데이터 접근 범위를 줄여 성능이 향상됨
- 많은 insert가 있는 시스템에서 insert를 파티션들로 분산시켜 경합을 줄임
- 전체 데이터의 훼손을 최소화하고 데이터 가용성이 향상됨
- 각 파티션별로 독립적 백업 및 복구가 가능
- 테이블의 파티션 단위로 Disk IO를 분산시켜 경합을 줄이므로 update 성능 향상
- 큰 테이블을 나누므로 관리가 용이해진다
- 테이블간 join 비용이 증가함
- table과 index를 별도로 파티셔닝 할 수 없다(같이 파티셔닝 해야한다)

## 종류

- 수평 파티셔닝(레코드별 분리 (1~100만/100만1~200만...), 샤딩과 동일한 개념이다)
- 수직 파티셔닝(컬럼별 분리)

## 파티셔닝 분할 기준

- 범위 분할
- 목록 분할
- 해시 분할
- 합성 분할

---

# Sharding

---

# Database Pool

## Connection Pool

- DB에 접근하기 위한 Connection을 여러개 생성한 뒤, 특정 공간에 저장해두고(캐싱해놓고) 필요할때마다 꺼내쓰고 반환하는것

## DB 접근 절차

- 어플리케이션 구동시 DB와 연결된 connection들을 여러개 생성해둔 뒤, pool에 저장한다
- DB 요청 수행 시, cp에서 connection을 가져와 사용하여 DB에 접근한다
- 사용 종료시 pool에 반환한다

## 생명주기 관리

- DB Connection은 제한시간이 존재한다
- 때문에 어플리케이션의 CP는 이 커넥션을 계속 살아있는 상태로 유지하기 위해 각자의 방법으로 커넥션을 계속 소생시킨다
    - Hikari CP: DB의 커넥션 타임아웃 시간 전에, 선제적으로 커넥션을 끊고 다시 받는다
    - Apache DBCP: DB의 커넥션 타임아웃 시간 전에, select 1과 같은 무의미한 쿼리를 날려 커넥션을 계속 유지시킨다 

---

# 정규화 1, 2, 3, BCNF

---

# Transaction

- 특정 범위의 SQL들을 반영할 지, 취소할지를 결정하여 최종적으로 실행하는것
- 기본적으로 트랜잭션 내 모든 작업들을 하나하나 수행하면서 상태를 확인하고, 마지막에 Rollback or Commit으로 수행 반영 여부를 결정한다
- 트랜잭션은 기본적으로 일반 수행보다 성능이 떨어진다

## ACID

- A: 원자성(Atomicity)
    - 트랜잭션 내 모든 연산들은 정상 수행되거나, 어떤 연산도 수행되지 않은 상태여야 함
- C: 일관성(Consistency)
    - 트랜잭션 완료 후에도 DB가 일관된 상태여야함
- I: 독립성(Isolation)
    - 하나의 트랜잭션이 실행 중일때 변경한 데이터는 이 트랜잭션 완료될때까지 다른 트랜잭션이 참조하지 못함
- D: 지속성(Durability)
    - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함 
    
## 트랜잭션의 단계

- Active: 트랜잭션이 실행중인 단계
- Failed: 트랜잭션 실행에 오류가 발생하여 중단한 단계
- Aborted: 취소되어 Rollback을 수행한 단계
- Partially Committed: 트랜잭션 모두 수행 후 Commit 전 단계
- Commited: commit 완료한 단계

---

# Transaction Isolation Level (트랜잭션 격리수준)

- 일관성 없는 데이터를 허용하도록 하는 수준
- ACID를 철저히 지키기 위해 Lock을 진행하는데, Lock이 심할수록 순차적으로 하나씩만 처리하므로 DB 성능이 저하된다
- 성능을 위해 Lock을 줄이면, 잘못된 데이터가 처리될 여지가 생긴다
- 그래서 ISO 레벨을 효율적으로 정해야 할 필요가 있음. 
    - ISO 레벨이 높을수록 비용이 높아진다

## ISO의 종류

### Read Uncommitted (lv 0)

- select이 수행되는 동안은 해당 데이터에 Shared lock이 걸리지 않는다
- 트랜잭션에 처리중이거나 커밋되지 않은 데이터를 다른 트랜잭션이 읽는것을 허용함
- 때문에 트랜잭션이 진행되며 변경된 Uncommitted or Dirty 데이터를 다른 곳에서 읽을수 있다
- 고로 DB의 일관성을 유지할 수 없다

### Read Committed (lv 1)

- select이 수행되는 동안 해당 데이터에 Shared lock이 걸린다
- 트랜잭션 수행되는 동안 다른 트랜잭션은 접근을 하지 못하고 대기하게 된다
- Commit이 끝난 트랜잭션만 조회가 가능하다
- SQL Server의 Default ISO 레벨이다

### Repeatable Read (lv 2)

- 트랜잭션이 완료될때까지 select이 사용하는 모든 데이터에 Shared lock이 걸린다
- 트랜잭션이 조회한 데이터의 내용이 항상 동일함을 보장받는다
- 따라서 다른 사용자는 그 영역에 해당하는 데이터 수정이 불가능하다

### Serializable (lv 3)

- 트랜잭션이 완료될때까지 select이 사용하는 모든 데이터에 Shared lock이 걸린다(lv 2와 같음)
- 완벽한 읽기 일관성을 제공한다
- 따라서 다른 사용자는 그 영역에 해당되는 데이터의 수정에 입력까지 불가능하다

### 주요 발생 이슈

- Dirty Read
    - 커밋되지 않은 수정중인 데이터를 다른 트랜잭션이 읽을수 있을때 발생하는 현상
    - 다른 트랜잭션에서 끝나지 않은 변경사항을 다른 트랜잭션이 보게 되는 경우
- Non-Repeatable Read
    - 한 트랜잭션에서 같은 쿼리를 두번 실행할 때, 그 사이 다른 트랜잭션이 값을 수정 혹은 삭제하여 두 쿼리의 결과가 상이하게 나타나는 현상
- Phantom read
    - 한 트랜잭션에서 특정 범위의 레코드를 두번 이상 읽을때, 첫 쿼리에서 없던 레코드가 추후 나타나는 현상
    - 이는 트랜잭션 도중 새로운 레코드가 삽입되는것을 허용했기 때문에 나타난다
    
---

# B+tree

- Root node(출발점) > non-leaf node(leaf node로의 경로 역할) > leaf node(실제 데이터가 저장되어 있음)
- hash table이 아닌 b+tree를 사용하는 이유
    - select에는 부등호 연산이 포함되기 때문에 동등연산에 유리한 hash table는 문제 발생할 수 있음
