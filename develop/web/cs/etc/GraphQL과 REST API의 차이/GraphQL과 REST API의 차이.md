# GraphQL과 REST API 비교

- GraphQL과 REST API는 클라이언트-서버 간 데이터 교환을 위한 기술로, 각각의 설계 철학과 데이터 처리 방식이 다름.
- REST API는 **자원(Resource)** 중심으로 설계된 고정된 엔드포인트 기반이고, GraphQL은 **클라이언트가 요청하는 데이터**를 동적으로 정의할 수 있는 쿼리 언어를 제공.

---

# 주요 차이점 비교

| **특징** | **REST API** | **GraphQL** |
| --- | --- | --- |
| **데이터 요청 방식** | 고정된 엔드포인트를 통해 요청 (예: `/users`, `/users/123`) | 단일 엔드포인트에서 클라이언트가 필요한 데이터만 요청 (예: `/graphql`) |
| **데이터 응답 구조** | 서버에서 정해진 응답 구조 반환 | 클라이언트가 쿼리로 요청한 데이터만 반환 |
| **오버페칭 문제** | 필요한 데이터 외에도 불필요한 데이터 포함 가능 | 필요한 데이터만 반환 |
| **언더페칭 문제** | 데이터를 완성하려면 여러 엔드포인트 호출 필요 | 단일 쿼리로 필요한 데이터 모두 반환 |
| **버전 관리** | URI 또는 헤더를 통해 버전 관리 | 버전 관리가 필요하지 않음 (스키마 변경으로 해결 가능) |
| **실시간 데이터 지원** | 기본적으로 지원되지 않음 | Subscription을 통해 실시간 데이터 처리 가능 |
| **문서화** | 별도 API 문서 필요 | 자체 스키마로 문서화 및 쿼리 탐색 지원 |

---

# REST API의 주요 특징

## **고정된 엔드포인트**

- 각 리소스마다 URI가 고정됨.
- 예:

    ```bash
    GET /users -> 사용자 목록 조회
    GET /users/123 -> 특정 사용자 정보 조회
    ```


## **표준 HTTP 메서드 활용**

- `GET`, `POST`, `PUT`, `DELETE` 등 HTTP 메서드로 데이터의 CRUD 작업을 수행.

## **오버페칭과 언더페칭 문제**

- 고정된 응답 구조로 인해 클라이언트가 필요한 데이터보다 더 많은 데이터를 받을 수 있음(오버페칭).
- 원하는 데이터를 얻기 위해 여러 엔드포인트를 호출해야 하는 경우 발생(언더페칭).

## **캐싱 지원**

- HTTP 캐시 헤더(`ETag`, `Cache-Control`)를 통해 간단히 캐싱 가능.

---

# GraphQL의 주요 특징

## **단일 엔드포인트**

- 모든 요청이 단일 엔드포인트(`/graphql`)를 통해 처리.
- 클라이언트는 원하는 데이터를 쿼리(Query)로 정의.

## **정확한 데이터 요청**

- 필요한 필드를 명시적으로 선언하여 요청.
- 예:

    ```graphql
    query {
      user(id: 123) {
        name
        email
        posts {
          title
          comments {
            text
          }
        }
      }
    }
    ```


## **스키마 기반 설계**

- GraphQL 스키마를 통해 데이터 구조를 정의.
- 클라이언트와 서버 간 데이터 계약을 명확히 함.

## **실시간 데이터 처리**

- Subscription을 통해 WebSocket 기반으로 실시간 데이터 업데이트 가능.

## **버전 관리 필요 없음**

- 새 필드 추가 시 기존 API는 그대로 유지되므로 버전 관리가 필요하지 않음.

---

# 장점과 단점

## REST API

### **장점**

- 간단하고 직관적이며 널리 사용됨.
- HTTP 표준과 잘 통합되어 있음.
- HTTP 캐싱과 CDN 지원으로 성능 최적화 용이.

### **단점**

- 오버페칭과 언더페칭 문제.
- 클라이언트가 여러 요청을 보내야 할 수 있음.
- 변경 사항 발생 시 버전 관리 필요.

## GraphQL

### **장점**

- 필요한 데이터만 정확히 요청 가능.
- 단일 쿼리로 여러 데이터 요청 가능.
- Subscription으로 실시간 데이터 지원.
- 명확한 스키마로 자동 문서화 가능.

### **단점**

- 초기 설정 및 학습 곡선이 있음.
- HTTP 캐싱 지원이 복잡함.
- 단순 API에는 오히려 과도한 도구일 수 있음.

---

# **요약**

- REST API는 고정된 엔드포인트와 HTTP 표준을 기반으로 하는 전통적인 설계 방식이며, 단순한 시스템에 적합.
- GraphQL은 클라이언트가 데이터 요청을 동적으로 정의할 수 있어 데이터 효율성과 실시간 처리가 중요한 복잡한 시스템에 적합.
- 프로젝트 요구사항에 따라 적절한 기술을 선택해야 함.