# API 확장성(Scalability)이란?

- API의 확장성은 트래픽 증가나 데이터 처리량 확대 시 성능 저하 없이 시스템을 확장할 수 있는 능력.
- REST API, GraphQL, gRPC 등 다양한 API 설계에서 확장성을 확보하면 대규모 사용자와 데이터 요청을 효율적으로 처리할 수 있음.

---

# API 확장성을 확보하는 주요 전략

## **수평 확장과 수직 확장**

### **수평 확장 (Horizontal Scaling)**

- 서버 인스턴스를 추가하여 부하를 분산.
- 로드 밸런서를 통해 트래픽을 균등 분배.
- 클라우드 서비스(AWS, GCP 등)를 이용한 동적 확장 지원.

### **수직 확장 (Vertical Scaling)**

- 서버의 하드웨어 성능(CPU, RAM, 저장소)을 업그레이드.
- 단일 서버의 처리 능력을 향상하지만, 한계가 존재.

---

## **로드 밸런싱**

- 트래픽을 여러 서버로 분산하여 과부하 방지.
- **방법**:
    - 라운드 로빈
    - 최소 연결 기반
    - IP 해싱 기반

**예: AWS ELB, Nginx, HAProxy**

```
upstream api_servers {
    server api1.example.com;
    server api2.example.com;
}

server {
    location / {
        proxy_pass http://api_servers;
    }
}
```

---

## **캐싱**

- 자주 요청되는 데이터를 미리 저장하여 처리 속도와 서버 부하 감소.
- **전략**:
    - 클라이언트 측 캐싱: 브라우저나 애플리케이션에서 HTTP 헤더를 활용해 데이터 캐싱.
    - CDN 캐싱: 정적 데이터(API 응답 포함)를 콘텐츠 전송 네트워크(CDN)에 저장.
    - 서버 측 캐싱: Redis, Memcached 등 인메모리 캐시 활용.

**예: HTTP 캐싱 헤더**

```arduino
Cache-Control: public, max-age=3600
```

---

## **비동기 요청 처리**

- API의 비동기 작업으로 서버의 동시 처리 능력 향상.
- **방법**:
    - 메시지 큐(RabbitMQ, Kafka 등)를 사용해 작업 분리.
    - 클라이언트는 작업 상태를 비동기로 확인(예: 폴링, 웹소켓).

**예: 비동기 작업 상태 확인 API**

```json
GET /tasks/123/status
{
  "status": "in-progress"
}
```

---

## **데이터베이스 최적화**

### **읽기-쓰기 분리**:

- 읽기 전용 복제본(Read Replica)으로 읽기 요청 분산.

### **샤딩(Sharding)**

- 데이터베이스를 여러 노드로 분산 저장하여 확장성 확보.

### **인덱싱**

- 쿼리 성능 향상을 위해 중요한 필드에 인덱스 설정.

### **캐싱 레이어 추가**

- 데이터베이스 요청 전에 Redis 같은 캐시 레이어에서 결과 제공.

---

## **API 게이트웨이 활용**

- 모든 요청을 API 게이트웨이를 통해 관리하여 확장성과 보안 강화.
- 기능:
    - 요청 라우팅
    - 로깅 및 분석
    - 인증 및 권한 부여
    - 속도 제한(Rate Limiting)

**예: AWS API Gateway**

- 트래픽 스파이크를 자동으로 처리.
- 다양한 API 버전과 마이크로서비스를 통합 관리.

---

## **스케일링 친화적인 설계**

### **RESTful 설계 준수**

- 리소스와 엔드포인트를 명확히 정의하여 트래픽 분산.

### **페이징 및 제한(Query Limiting)**

- 대량 데이터를 한 번에 반환하지 않고, 페이지 단위로 나누어 제공.

**예: 페이징 API 응답**

```json
GET /users?page=2&limit=10
{
  "data": [
    { "id": 11, "name": "User11" },
    { "id": 12, "name": "User12" }
  ],
  "page": 2,
  "total_pages": 5
}
```

- **쿼리 필터링**
    - 클라이언트가 필요한 데이터만 요청하도록 설계.

    ```json
    GET /users?fields=name,email
    ```


---

## **서버리스 아키텍처**

- 서버리스 플랫폼(AWS Lambda, Google Cloud Functions)을 사용해 동적으로 리소스를 할당.
- 이벤트 기반 처리로 트래픽 변동에 유연하게 대응.
- 유지보수와 초기 비용을 낮출 수 있음.

---

# 장점

- 대규모 트래픽 처리 능력 확보.
- 사용자 경험 개선(응답 시간 단축).
- 시스템 안정성 및 가용성 향상.

# 단점

- 설계와 구현의 복잡성 증가.
- 비용 상승(특히 클라우드 환경에서).
- 모니터링 및 디버깅 부담 증가.

---

# **요약**

- API 확장성을 확보하기 위해 수평 확장, 로드 밸런싱, 캐싱, 비동기 처리, 데이터베이스 최적화, API 게이트웨이 등을 활용.
- 클라우드 기반 기술과 설계 원칙을 결합하면 효율적인 확장성과 안정성을 동시에 달성 가능. 요구사항에 따라 적절한 전략을 조합하여 적용해야 함.