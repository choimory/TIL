# 목차

- [Java SE와 EE의 차이](#-java-se와-ee의-차이)
- [Java와 CPP의 차이](#-Java와-CPP의-차이)
- [Java의 장단점](# Java의 장단점)
- [Java의 접근 제어자 종류](# Java의 접근 제어자 종류)
- [static](#-static)
- [Java 데이터 타입](# Java 데이터 타입)
- [Wrapper class](# Wrapper class)
- [OOP 특징](# OOP 특징)
- [OOP 5대 원칙 (SOLID)](# OOP 5대 원칙 (SOLID))
- [객체지향과 절차지향의 차이](# 객체지향과 절차지향의 차이)
- [Java 인스턴스 필드와 static 필드의 차이](# Java 인스턴스 필드와 static 필드의 차이)
- [Java 메인 메소드가 static인 이유](# Java 메인 메소드가 static인 이유)
- [Java의 static 메모리 활용 방식](# Java의 static 메모리 활용 방식)
- [Java의 final, finally, finalize](# Java의 final, finally, finalize)
- [직렬화와 역직렬화](# 직렬화와 역직렬화)
- [클래스, 객체, 인스턴스의 차이](# 클래스, 객체, 인스턴스의 차이)
- [오버로딩과 오버라이딩의 차이](# 오버로딩과 오버라이딩의 차이)
- [Call by Ref와 Call by Value의 차이](# Call by Ref와 Call by Value의 차이)
- [인터페이스와 추상 클래스의 차이](# 인터페이스와 추상 클래스의 차이)
- [JVM 구조](# JVM 구조)
- [String, StringBuffer, StringBuilder](# String, StringBuffer, StringBuilder)
- [동기화와 비동기화의 차이](# 동기화와 비동기화의 차이)
- [Java에서 ==와 equals()의 차이](# Java에서 ==와 equals()의 차이)
- [Java의 리플렉션](# Java의 리플렉션)
- [Lambda](# Lambda)
- [Stream](# Stream)
- [동기화, 비동기화](# 동기화, 비동기화)
- [Annotation](# Annotation)
- [GC 처리 방법](# GC 처리 방법)
- [제네릭스](#-제네릭스)

---

# Java SE와 EE의 차이

- SE: Standard Edition, 기본적인 JDK만 포함
- EE: Enterprise Edition, 모든 JDK 포함

---

# Java와 CPP의 차이

- Java는 실행환경에서 컴파일러가 바로 바이트 코드를 생성하지만, cpp는 컴파일 외에 링크라는 과정이 존재한다

---

# Java의 장단점

- 운영체제에 구애받지 않음
- OOP
- GC에게 메모리관리 위임하여 비즈니스 로직 집중
- 멀티 스레딩
- 동적 로딩
    - 어플리케이션 시작이 아닌, 객체 필요 시점에 특정 클래스 로딩
- 느린 속도
- 예외처리

---

# Java의 접근 제어자 종류

- public: 전체 접근 가능
- protected: 같은 클래스 및 상속 관계만 접근 가능
- default: 같은 패키지간 접근 가능
- private: 클래스 내에서만 접근 가능

---

# static 

- 클래스의 인스턴스 필드나 메소드와 관련이 없는, 독립적인 클래스, 필드 혹은 메소드는 static을 부여할 수 있다.
- static은 인스턴스와 관련이 없으므로 어떤 인스턴스를 생성하던 결과가 똑같다. 
- 즉 메모리에 인스턴스별로 여러개를 올릴 필요가 없다는 뜻이므로, 클래스 로딩시에 JVM 메소드 메모리 영역에 하나만 올라간다.
- 인스턴스와 관련이 없으므로 사용시에도 인스턴스 생성 없이 사용이 가능하다.

---

# Java 데이터 타입

## primitive

- boolean(true, false) < byte(1byte) < char(2byte) < short(2byte) < int(4byte) < float(4byte) < long(8byte) < double(8byte)
- JVM stack 영역에 저장됨

## Reference

- 기본형 제외 전부
- JVM Heap 영역에 저장되며, 아무도 참조 중이지 않을시엔 GC에 의해 destroyed 됨
- 변수에 값이 아닌 heap 영역의 주소가 초기화 됨

---

# Wrapper class

- 기본형의 객체화
- 타입, 제네릭, null 체크 등 여러 필요성에 의해 생김
- 개발시 기본형보다는 래퍼클래스의 사용을 권장
- 객체이므로 new 연산자 등을 이용해 박싱, 언박싱하여 생성해야 하지만, JDK 1.5부터 컴파일러가 오토 박싱, 오토 언박싱을 진행해준다

---

# OOP 특징

## 추상화

- 객체의 공통점을 파악하여 하나의 개념 및 집합으로 다룸

## 캡슐화

- 불필요한 내용들은 외부 접근을 못하게 막는것
- 높은 응집도와 낮은 결합도를 갖추게 함

## 상속

- 여러 객체의 공통점을 하나의 상위로 묶고 내려받게 함

## 다형성

- 다른 클래스의 객체들이 각자의 방식으로 동작하게 함
- 오버로딩, 오버라이딩

---

# OOP 5대 원칙 (SOLID)

## S: 단일 책임 원칙, SRP(Single Responsibility Principle) 

- S = Single
- 클레스는 하나의 책임만을 가져야하고, 클래스를 변경하는 이유도 하나여야 함

## O: 개방-폐쇄 원칙, OCP(Open-closed Principle)

- O = Open
- 확장은 열려있어야 되고, 변경은 닫혀있어야 함

## L: 리스코프 치환 원칙, LSP(Liskov Subsitution Principle)

- L = 리스코프
- 상위타입을 하위타입으로 치환하여도, 상위타입을 사용하는 프로그램에 문제가 없어야 함

## I: 인터페이스 분리 원칙, ISP(Interface Segregation Principle)

- I = 인터페이스
- 인터페이스는 그것을 사용하는 클라이언트 기준으로 분리해야함

## D: 의존 역전 원칙, DIP(Dependency Inversion Principle)

- D = Dependency
- 고수준 모듈은 저수준 모듈에 의존해서는 안됨

---

# 객체지향과 절차지향의 차이

## 절차지향 

- 실행 절차를 정해 순서대로 프로그래밍, 목적 달성에 중점을 둠

## 객체지향

- 대상을 객체로 표현하고 객체사이의 관계 및 상호작용을 프로그래밍으로 표현한다
- 객체에 필요한 필드와 메소드를 설계 및 구현한다
- 연관된 필드와 메소드를 하나로 그룹핑하는것이 중요하다

---

# Java 인스턴스 필드와 static 필드의 차이

- 인스턴스 필드
  - 인스턴스마다 값이 변해야 되는 경우
  - 스프링 컨텍스트로부터 인스턴스를 주입받아야 하는 경우
- static 핃르
  - 모든 인스턴스가 같은 값을 고정적으로 사용하는 경우
  - 주입받을 필요 없이 사전부터 초기화되어 사용되는 경우

---

# Java 메인 메소드가 static인 이유

- 메인 메소드가 작성된 클래스의 인스턴스는 생성되어있지 않았을 것이므로, 인스턴스 없이 호출할 수 있는 static 메소드 여야 함
  - static은 클래스 로딩시에 메모리에 로드되므로 인스턴스와 별개이며 독립적이다
- JVM은 Method Area에 저장된 static 메소드인 main()을 실행함

---

# Java의 static 메모리 활용 방식

- JVM Method Area(Class Area 혹은 Static Area라고도 불림) 메모리에 하나만 로드하여 범용적으로 사용한다
- 코드를 실행하면 컴파일러가 .java를 .class(바이트 코드)로 변환한다
- 클래스 로더가 .class 파일을 메모리 영역(Runtime Data Area)에 로드한다
- Runtime Data Area 중 Method Area라고 불리는 영역에 Class Variable을 저장하는데, static도 이때 여기에 포함된다

---

# Java의 final, finally, finalize

- final: 초기화 이후 값이 변해지는것을 금지
- finally: try catch 이후 공통적으로 수행되어야 하는 로직을 수행
- finalize: 특정 인스턴스의 종료 메소드

---

# 직렬화와 역직렬화

## 직렬화

- JVM에 올라간 객체 데이터를 외부에서도 사용할 수 있도록 바이트 형태로 변환하는것
- Serializeable을 상속 받거나 구현한 객체여야 한다

## 역직렬화

- 바이트 형태의 데이터를 다시 객체로 변환하여 JVM 메모리에 올리는것
- 직렬화할 클래스가 클래스 패스에 존재해야 하고 import 되어있어야 함
- 직렬화 대상 객체는 동일한 serialVersionUID를 가지고 있어야 함

---

# 클래스, 객체, 인스턴스의 차이

- 클래스는 객체에 대한 설계도
- 인스턴스는 해당 클래스로 만들어낸 실제 결과
- 객체는 모든 인스턴스를 포괄적으로 지칭

---

# 오버로딩과 오버라이딩의 차이

- 오버로딩: 같은 메소드를 다른 파라미터로 여러개 만드는것
- 오버라이딩: 상속받은 메소드를 재정의하는것

---

# Call by Ref와 Call by Value의 차이

## Call by Value

- 기본형의 값을 복사하여 전달한다
- 복사된 값은 또 다른 지역변수의 특성을 지닌다
- 때문에 해당 값을 변경하여도 기존 값과는 별개로 존재하므로, 외부의 값은 변하지 않는다.

## Call by Reference

- 참조형의 주소를 그대로 전달한다
- 결국 한곳의 Heap 메모리 주소를 공유하게 되므로 값을 변경할시, 해당 메모리를 참조하는 모든 곳에 영향을 받는다.

---

# 인터페이스와 추상 클래스의 차이

- 인터페이스는 상수와 public 메소드 선언, default 메소드 작성만 가능하다
- 추상 클래스는 일반 클래스와 비슷하게 작성이 가능하나, 구현이 필요한 메소드가 하나라도 있을경우 추상클래스 선언이 가능하다
- 고로 인터페이스가 더 제한적이며, 더 많은 구현을 필요로 하므로 미리 구현해야 할 메소드나 필드가 있을 경우 추상클래스를, 그렇지 않은 경우 인터페이스 사용을 고려 할 수 있다.

---

# JVM 구조

## Method Area (Class Area, Static Area)

- 클래스 메타 데이터, static 데이터 등이 올라간다
- 클래스가 사용될때 JVM이 해당 클래스를 읽고 분석해서, 클래스의 멤버들을 Method Area에 저장한다
- 이때 저장되는 정보들은 다음과 같음
  - Type 정보: 패키지와 클래스명, 하위 클래스명 전체, 클래스/인터페이스 여부, 접근제어자 정보, 연관된 인터페이스들 
  - Field 정보: 필드 타입과 접근제어지
  - Method 정보: 메소드명, 반환타입, 파라미터와 타입, 접근제어자, 구현여부, 메소드의 바이트코드 등
  - 상수 정보: Runtime Constant Pool, 상수들을 저장함
  - static 변수 정보: 이때 final static은 constant pool에 값이 복사되며, 일반 static은 Heap의 인스턴스와 연결됨

## Stack Area

- 메소드 실행 정보 및 지역변수 등이 올라간다
- Stack 형태로 되어 있어, FILO이다.

## Heap Area

- 인스턴스 생성 정보가 올라간다
- 주소 형태로 관리되며, 모든 참조형 변수는 Heap Area의 주소가 저장된다
- 참조되지 않는 인스턴스는 GC에 의해 정리된다

---

# String, StringBuffer, StringBuilder

## String

- 내부에 private final char[]로 데이터를 받게 되어있음
- 때문에 값을 변경할때마다 새로운 인스턴스가 생성됨
- 결국 stack에 계속 각각의 인스턴스가 쌓이고, heap에도 메모리가 계속 쌓인다
- JDK 1.5부터는 컴파일시 모든 String 연산을 StringBuilder로 바꾸어서 컴파일함
= 하지만 반복문에서는 객체를 새로운 메모리에 계속 할당하므로, String 사용은 지양하는것이 좋다

## StringBuffer, StringBuilder

- memory에 append하는 형식으로 하나의 객체를 사용한다
- 둘의 차이는 동기/비동기, 쓰레드세이프 여부이다
- Builder가 비동기, Buffer가 동기, 쓰레드세이프 지원함

---

# 동기화와 비동기화의 차이

## 동기

- 순차
- 동시접근 제한
- synchronized
  - 멀티스레드 접근 제한 키워드
  - 메소드, 블록단위 지정가능
  - 메소드 사용시 메소드락이 걸리므로 임계는 최소한으로 잡자

## 비동기

- 현재 실행중인 명령 종료와 상관없이 다음작업 진행 가능
- 콜백으로 결과 확인

---

# Java에서 ==와 equals()의 차이

## ==

- 값을 비교
- 객체시에는 객체 주소를 비교
- 모든 타입에 사용 가능

## equals()

- 객체를 비교, 두 객체의 값이 같은지를 확인한다
- primitive type에서는 적용할 수가 없다

---

# Java의 리플렉션

- 클래스 로딩하여 Method area에 저장된 클래스 메타데이터들을 확인하는것
- 클래스의 패키지 정보, 접근제어자, 상위 클래스, 어노테이션 등을 확인 가능
- 컴파일이 아닌 런타임에 동적으로 특정 클래스의 정보를 객체적으로 분석 및 확인할 수 있음

## 사용이유

- 런타임에 다른 클래스를 동적으로 확인할 때
- 클래스의 정보를 얻어야 할때

## 주의

- 리플렉션을 이용한 로직은 성능 문제가 있을 수 있다
- private 메소드도 Field.setAccessible()을 거쳐 접근이 가능해질 수 있다

---

# Lambda

- Java 8에서 등장
- 메소드를 식으로 표현하는것
- 람다는 익명 클래스를 활용하는것을 원리로 구현되었으므로 이를 활용한 함수형 인터페이스를 통해서만 사용이 가능하다
  - 익명 클래스를 토대로 만들었으므로 지역변수에 접근이 불가능하다
  - 인터페이스 내에 하나의 추상메소드만 정의하고, 해당 인터페이스를 매개변수로 넘기면서 구현부를 작성하는것
- 이 방식으로 함수를 일급 객체로 사용할 수 없는 단점도 보완한다
- 코드가 줄어들고 병렬 프로그래밍에 유용하나, 코드 이해 및 디버깅이 쉽지 않다는 단점도 있다
- 익명 함수와는 다르게 컴파일
- 익명 함수는 별도 클래스의 인스턴스를 생성
- Lambda는 'invokedynamic'을 사용하여 Lambda 표현식 구현을 위한 코드 생성을 런타임 시 까지 연기
- 런타임 시에 어떤 방법으로 객체를 생성할지 결정하는데, 성능 향상을 위한 최적화된 방법 사용

---

# Stream

- Java 8에서 등장
- 정제, 변환, 정렬, 필터링, 그루핑 등 데이터를 다루는 용도로 사용된다
- 병렬 프로그래밍에 유리하다
- 코어가 많고 데이터가 많고 처리시간이 길 수록 병렬 처리 성능이 향상된다
  - 단 LinkedList는 순차가 더 좋을 수 있다
- 원본 데이터를 훼손하지 않는다
- 코드를 단순화 할 수 있다

---

# Annotation

---

# GC 처리 방법

- GC는 메모리 할당, 사용중인 메모리와 미사용 메모리를 파악한다
- GC 실행시 GC를 제외한 모든 스레드가 중단되며, GC가 끝나면 다시 실행시킨다(GC의 Stop the world)
- Heap에는 Eden < Survive1 < Survive2 < Old 영역이 존재
  - 이때 Eden에서 Minor GC 발생시 참조 중인 객체는 Survive1로 이동
  - Survive1에서 Minor GC 발생시 참조 중인 객체는 Survive2로 이동
  - Survive2에서 Minor GC 발생시 참조 중인 객체는 다시 Survive1로 이동 (이과정에서 Survive1<->Survive2를 반복함)
  - Survive 영역이 가득차거나 Young에서 많이 살아남은 객체는 Old로 이동(시간이 아닌 살아남은 횟수)
  - Old에 있는 객체는 Major GC가 발생시 공간이 유지되거나 제거된다

---

# 제네릭스

- 

---