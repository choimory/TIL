# @Embeddable과 @Embedded를 사용하는 이유

- **`@Embeddable`**: 값 타입 클래스를 정의할 때 사용. 다른 엔티티에 포함되어 그 엔티티의 속성으로 사용됨.
- **`@Embedded`**: 엔티티가 `@Embeddable` 클래스를 포함할 때 사용. 값 타입 클래스의 필드를 엔티티 테이블의 컬럼으로 매핑.
- 이를 통해 **객체 지향적 설계**를 유지하면서도 **코드 재사용성**을 높이고, **복잡한 속성**을 쉽게 관리할 수 있음.
- @Embeddable
    - `@Embeddable`은 **값 타입(Embeddable Type)으로 사용할 클래스**에 붙이는 어노테이션. 이 클래스는 독립적인 엔티티가 아니며, 다른 엔티티에 포함되어 그 엔티티의 속성으로 사용됨.
    - 특정 엔티티 내에서 재사용 가능한 속성들을 **캡슐화**하고, 이를 여러 엔티티에서 공유하거나 재사용할 때 사용.
    - 특징
        - **독립적인 테이블로 매핑되지 않음**.
        - 해당 클래스는 **다른 엔티티에 포함**되어 테이블의 일부 컬럼으로 사용됨.
        - 자주 사용되는 속성(예: 주소, 연락처, 좌표 등)을 묶어서 하나의 클래스로 정의할 수 있음.
    - 코드

        ```java
        @Embeddable
        public class Address {
            private String street;
            private String city;
            private String zipcode;
            
            // 기본 생성자, getter/setter
        }
        
        ```

      위의 `Address` 클래스는 독립적인 엔티티가 아닌, 다른 엔티티에 포함될 수 있는 **값 타입 클래스**임.

- @Embedded
    - `@Embedded`는 **엔티티 클래스에서 다른 `@Embeddable` 클래스**를 포함할 때 사용하는 어노테이션. 이 클래스의 필드가 엔티티의 일부로 취급되어 **같은 테이블의 여러 컬럼에 매핑됨**.
    - 엔티티가 **다른 `@Embeddable` 클래스를 포함**할 때 사용. 포함된 값 타입의 필드를 엔티티의 속성으로 관리하고, 데이터베이스 테이블에 해당 값들을 컬럼으로 매핑.
    - **특징**:
        - **내부 필드들이 독립적으로 컬럼에 매핑됨**.
        - `@Embedded` 클래스는 여러 엔티티에서 재사용될 수 있음.
    - 코드

        ```java
        @Entity
        public class User {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;
        
            private String name;
        
            @Embedded
            private Address address;  // Address 타입을 포함
        
            // 기본 생성자, getter/setter
        }
        
        ```

      위의 `User` 엔티티는 `Address`를 **포함하고 있으며**, `address` 필드는 `User` 테이블의 컬럼으로 저장됨.

- 사용이유
    - **코드 재사용성 증가**
        - 자주 사용하는 속성(예: 주소, 좌표, 금액 등)을 **캡슐화하여 재사용**할 수 있음.
        - 여러 엔티티에서 **같은 속성들을 반복적으로 정의하는 대신**, 이를 **값 타입 객체**로 만들어 엔티티에서 사용 가능.
    - **객체 지향적인 설계**
        - 엔티티의 속성을 더 **객체 지향적으로 관리**할 수 있음. 엔티티는 단일 데이터 타입 필드만 가질 수 있는 것이 아니라, **다양한 객체를 필드로 가질 수 있음**.
        - 테이블은 평면적인 구조이지만, **코드에서는 복잡한 객체 관계**를 사용할 수 있음.
    - **데이터베이스와의 일관성**
        - JPA는 **값 타입 객체의 필드들을** 데이터베이스의 컬럼으로 매핑해주므로, **코드와 데이터베이스 간의 일관성**이 높아짐.
        - `@Embeddable` 클래스를 여러 엔티티에서 공유하더라도, 각각의 엔티티에 맞는 컬럼으로 매핑됨.
    - **복잡한 매핑을 단순화**
        - 하나의 객체를 여러 속성으로 분리하여 사용해야 할 때, JPA가 자동으로 이를 매핑해주므로 복잡한 매핑 작업을 단순화할 수 있음.