# JPA @Version 사용 이유와 역할

- `@Version`은 **낙관적 잠금**을 구현하여 동시성 문제를 해결하는 데 사용됨.
- 엔티티의 버전 정보를 통해 **트랜잭션 간의 충돌을 감지**하고, 데이터의 일관성과 무결성을 보장.
- **멀티스레드 환경**이나 **다중 사용자** 애플리케이션에서, **동시에 여러 트랜잭션이 같은 데이터를 수정하려고 할 때 발생하는 충돌을 방지**하기 위해 사용됨.
- **`@Version`의 역할**
    - **낙관적 잠금(Optimistic Locking) 구현**
        - **낙관적 잠금**은 트랜잭션이 충돌하지 않을 것이라는 가정 하에 동작함. 즉, 데이터베이스에서 데이터를 수정할 때 **잠금을 걸지 않지만**, **업데이트 시점에 충돌 여부를 확인**하여 충돌이 발생하면 롤백하는 방식.
        - `@Version`은 엔티티의 버전을 관리하여, **수정할 때마다 버전 번호를 자동으로 증가**시킴. 이를 통해 **동시에 여러 트랜잭션이 같은 데이터를 수정하려고 할 때 충돌**을 감지할 수 있음.
    - **데이터 무결성 보장**
        - 여러 사용자가 동시에 같은 데이터를 수정할 경우, **데이터가 의도치 않게 덮어씌워지는 문제**를 방지.
        - 트랜잭션 간의 **경합을 최소화**하면서도, 데이터가 일관성 있게 유지되도록 보장.
- **동작 방식**
    - 엔티티에 `@Version` 어노테이션을 붙인 필드는 **트랜잭션이 성공적으로 완료될 때마다** 값이 증가.
    - **트랜잭션 시작 시점**에 엔티티의 **버전 정보를 확인**하고, **트랜잭션 커밋 시점**에 현재 버전과 데이터베이스에 저장된 버전이 같은지 비교.
    - **버전 불일치가 발생**하면, 다른 트랜잭션이 해당 데이터를 먼저 수정한 것이므로, **낙관적 잠금 예외(OptimisticLockException)**가 발생하여 트랜잭션이 롤백됨.
- 예시

  - 1. **기본적인 사용 예시**

    ```java
    @Entity
    public class Product {
    
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String name;
    
        private int stock;
    
        @Version
        private int version;  // 버전 필드
    }
    ```

    - `version` 필드는 JPA가 관리하는 버전 필드로, **데이터베이스에 저장될 때 자동으로 증가**.
    - **트랜잭션이 완료**될 때마다 `version` 값이 증가하고, 이를 통해 **동시성 충돌을 감지**.

  - 2. **동시성 제어 시나리오**

    - **상황**: 두 사용자가 `Product` 엔티티의 `stock` 값을 수정하려고 함.
        1. **User A**가 `Product` 엔티티를 읽어오고, `stock`을 50에서 60으로 변경.
        2. **User B**도 동일한 엔티티를 읽어와, `stock`을 50에서 55로 변경.
        3. **User A**가 트랜잭션을 커밋하면, **version** 필드가 0에서 1로 증가.
        4. **User B**가 트랜잭션을 커밋하려고 할 때, **User A**가 이미 데이터를 수정했으므로, **버전 값이 일치하지 않아 `OptimisticLockException` 발생**.
    - 이로 인해 **User B**의 트랜잭션은 롤백되며, 데이터 충돌이 발생했음을 알 수 있음.
- 장점
    - **데이터 무결성 보장**:
        - 여러 트랜잭션이 동시에 데이터를 수정하려고 할 때, **낙관적 잠금을 통해 데이터가 의도치 않게 덮어씌워지는 것을 방지**.
    - **잠금 비용이 낮음**:
        - 비관적 잠금(Pessimistic Locking)처럼 데이터베이스에서 행을 잠그지 않고, 버전 비교를 통해 충돌을 감지하므로, **데드락이나 잠금 경합**이 발생하지 않음.
    - **성능 최적화**:
        - 낙관적 잠금을 사용하므로, **트랜잭션 충돌이 자주 발생하지 않는 환경**에서는 성능을 유지하면서 동시성을 제어 가능.
- 단점
    - **낙관적 잠금 예외 처리**:
        - 낙관적 잠금은 **트랜잭션 종료 시점에 충돌을 감지**하므로, 충돌이 발생할 경우 예외를 처리할 로직이 필요. `OptimisticLockException`을 적절하게 처리해야 함.
    - **충돌 발생 빈도가 높다면 비효율적**:
        - 충돌이 빈번히 발생하는 환경에서는 **낙관적 잠금** 대신, **비관적 잠금**을 사용하는 것이 더 적합할 수 있음.
- 비교

    | **특징** | **낙관적 잠금 (`@Version`)** | **비관적 잠금 (Pessimistic Lock)** |
    | --- | --- | --- |
    | **잠금 방식** | 충돌 가능성을 가정하고 트랜잭션 종료 시점에 확인 | 트랜잭션 시작 시점에 데이터베이스에서 잠금 |
    | **데드락 발생 여부** | 데드락 발생하지 않음 | 잠금 경합 및 데드락 가능성 존재 |
    | **성능** | 충돌이 드물다면 성능이 좋음 | 잠금으로 인해 성능 저하 발생 가능 |
    | **사용 사례** | 충돌이 드물지만 동시성 처리가 필요한 경우 | 충돌이 빈번하게 발생하는 경우 |
