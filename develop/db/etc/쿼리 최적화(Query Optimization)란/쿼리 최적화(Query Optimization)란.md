# 쿼리 최적화(Query Optimization)란

- 쿼리 최적화(Query Optimization)는 데이터베이스에서 **SQL 쿼리의 성능을 최적화**하기 위한 과정이다.
- 이는 동일한 결과를 반환하는 여러 쿼리 실행 경로 중에서 **가장 효율적인 경로**를 선택하여, 데이터베이스의 자원 사용을 최소화하고 응답 속도를 높이는 것을 목표로 한다.
- 데이터베이스 관리 시스템(DBMS)은 일반적으로 쿼리 최적화기(Query Optimizer)를 통해 사용자가 작성한 SQL 쿼리를 최적화된 실행 계획으로 변환한다.
- 이 과정에서는 쿼리의 실행 순서, 인덱스 사용 여부, 조인 순서 등을 결정하여 쿼리가 빠르게 실행되도록 최적화한다.

---

# 쿼리 최적화의 필요성

- **성능 향상**:
    - 쿼리를 최적화하면 데이터 검색 속도를 크게 향상시킬 수 있다.
    - 이는 특히 대용량 데이터를 처리하거나 다중 사용자가 동시에 쿼리를 실행하는 시스템에서 중요하다.
- **자원 절약**:
    - 최적화된 쿼리는 CPU, 메모리, 디스크 I/O 등의 시스템 자원을 효율적으로 사용하여 부하를 줄일 수 있다.
- **대기 시간 감소**:
    - 쿼리가 효율적으로 실행되면 응답 시간이 줄어들어 사용자 경험이 개선된다.

---

# 쿼리 최적화를 위한 전략

## **인덱스 사용**

- 인덱스를 적절히 사용하는 것은 쿼리 성능을 크게 향상시킬 수 있다.
- 특히 **WHERE**, **JOIN**, **ORDER BY**, **GROUP BY**에 사용되는 열에 인덱스를 생성하면 전체 테이블을 스캔하지 않고도 빠르게 데이터를 조회할 수 있다.
- **예시**:
    - 고객 테이블에서 `customer_id`를 조건으로 검색할 때, 해당 컬럼에 인덱스가 있으면 검색 속도가 크게 향상된다.

    ```sql
    SELECT * FROM customers WHERE customer_id = 12345;
    ```


## **SELECT 절에서 불필요한 열 제외**

- `SELECT *`를 사용하는 대신 필요한 열만 선택하는 것이 성능을 향상시킨다.
- 불필요한 데이터를 읽고 처리하는 것을 줄일 수 있다.
- **예시**:

    ```sql
    -- 비효율적 쿼리
    SELECT * FROM orders WHERE order_date = '2023-01-01';
    
    -- 최적화된 쿼리
    SELECT order_id, customer_id FROM orders WHERE order_date = '2023-01-01';
    ```


## **조인 순서 최적화**

- 여러 테이블을 조인할 때는 조인의 순서가 성능에 큰 영향을 미칠 수 있다.
- 작은 테이블을 먼저 조인하고, 큰 테이블을 나중에 조인하는 것이 성능에 유리할 수 있다.
- 데이터베이스는 최적화기를 통해 가장 효율적인 조인 순서를 선택한다.
- **예시**:
    - `customers` 테이블이 작고 `orders` 테이블이 클 경우, `customers` 테이블을 먼저 처리하는 것이 더 효율적일 수 있다.

    ```sql
    SELECT c.customer_name, o.order_id
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id;
    ```


## **서브쿼리 대신 JOIN 사용**

- 서브쿼리(특히 중첩된 서브쿼리)는 성능을 저하시킬 수 있으므로, 가능하면 **JOIN**으로 대체하는 것이 좋다.
- JOIN은 일반적으로 서브쿼리보다 빠르게 실행된다.
- **예시**:

    ```sql
    -- 비효율적 서브쿼리
    SELECT c.customer_name
    FROM customers c
    WHERE c.customer_id IN (SELECT customer_id FROM orders WHERE order_date = '2023-01-01');
    
    -- 최적화된 조인
    SELECT c.customer_name
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id
    WHERE o.order_date = '2023-01-01';
    ```


## **인덱스 스캔(Index Scan) 대신 인덱스 탐색(Index Seek) 사용**

- 인덱스가 있을 때, 인덱스 탐색(Index Seek)은 필요한 데이터만 빠르게 조회하지만, 인덱스 스캔(Index Scan)은 인덱스를 모두 읽는 방식이므로 비효율적이다.
- 인덱스를 효율적으로 사용하기 위해 조건에 맞는 범위를 좁히는 것이 중요하다.
- **예시**:

    ```sql
    -- 인덱스 탐색을 활용한 쿼리
    SELECT * FROM orders WHERE order_id = 12345;
    ```


## **조인 대신 EXISTS 또는 NOT EXISTS 사용**

- 조건부 존재 여부를 확인할 때는 `JOIN`보다는 `EXISTS`를 사용하는 것이 성능을 향상시킬 수 있다.
- 특히, **중복 데이터**가 많을 경우 `EXISTS`가 더 빠르게 동작한다.
- **예시**:

    ```sql
    -- 비효율적인 조인
    SELECT c.customer_name
    FROM customers c
    LEFT JOIN orders o ON c.customer_id = o.customer_id
    WHERE o.order_id IS NULL;
    
    -- 최적화된 EXISTS 사용
    SELECT c.customer_name
    FROM customers c
    WHERE NOT EXISTS (
        SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id
    );
    ```


## **GROUP BY 및 DISTINCT 최적화**

- **GROUP BY**나 **DISTINCT**를 사용할 때는 인덱스를 적절히 활용하여 성능을 개선할 수 있다.
- 중복 데이터가 많은 경우, 이를 적절하게 처리하기 위한 인덱스를 생성하면 성능 향상에 도움이 된다.
- **예시**:

    ```sql
    SELECT customer_id, COUNT(*) FROM orders
    GROUP BY customer_id;
    ```


## **LIMIT 또는 OFFSET 사용**

- 전체 데이터를 조회하지 않고, 필요한 데이터만 가져오기 위해 **LIMIT**(또는 **OFFSET**)를 사용하면 성능이 크게 향상될 수 있다.
- 특히, 대용량 데이터를 다룰 때는 이 방식으로 쿼리 성능을 최적화할 수 있다.
- **예시**:

    ```sql
    SELECT * FROM products ORDER BY product_name LIMIT 100;
    ```


## **분할 테이블(Partitioning) 사용**

- 데이터가 매우 클 경우, 테이블을 물리적으로 분할하는 파티셔닝(Partitioning)을 사용하면 검색 성능을 크게 향상시킬 수 있다.
- 파티셔닝은 데이터를 **범위** 또는 **해시** 방식으로 분할하여 특정 파티션에만 접근하도록 최적화한다.
- **예시**:
    - 날짜 범위에 따라 주문 데이터를 여러 파티션에 저장하고, 필요한 파티션에서만 데이터를 검색.

## **데이터 중복 방지 및 정규화**

- 테이블을 **정규화**하여 데이터 중복을 최소화하면, 데이터가 적어져 쿼리 성능이 향상될 수 있다.
- 정규화는 특히 **쓰기 성능**과 **데이터 일관성**을 유지하는 데 도움이 된다.

## **실행 계획(Execution Plan) 분석**:

- 데이터베이스에서 제공하는 **실행 계획**을 통해 쿼리의 실행 경로를 분석하고, 최적화할 수 있는 부분을 찾아낸다.
- 실행 계획을 보면, 데이터베이스가 어떻게 쿼리를 처리하는지 확인할 수 있다.

## **통계 정보(Statistics) 업데이트**:

- 데이터베이스는 **통계 정보**를 바탕으로 최적의 실행 계획을 선택한다.
- 따라서 데이터가 많이 변경되면 통계를 주기적으로 업데이트하여 쿼리 최적화가 제대로 이루어지도록 해야 한다.

## **쿼리 리팩토링**:

- 복잡한 쿼리를 단순화하거나, 여러 개의 작은 쿼리로 나누어 실행하는 방법도 성능을 높이는 데 도움이 될 수 있다.
- 복잡한 논리를 쿼리 안에서 한 번에 처리하려고 하지 말고, 필요한 경우 단계적으로 처리하는 것도 좋은 전략이다.

---

# 정리

- 쿼리 최적화(Query Optimization)는 데이터베이스 성능을 극대화하기 위한 핵심 과정으로, 다양한 기법과 전략을 통해 쿼리 실행 속도를 높이고 자원 사용을 줄일 수 있다.
- 적절한 **인덱스 활용**, **쿼리 구조의 최적화**, **조인 방식의 개선** 등은 쿼리 성능을 크게 향상시킬 수 있다.
- 또한, 쿼리 실행 계획을 분석하고, 통계 정보를 주기적으로 관리하여, 데이터베이스가 최적으로 쿼리를 실행할 수 있도록 돕는 것이 중요하다.
- 쿼리 최적화를 위해 다양한 전략을 적용하면 데이터베이스의 성능이 크게 향상될 수 있으며, 특히 **대규모 데이터**와 **다중 사용자 환경**에서 그 효과가 두드러진다.
- 따라서 쿼리 작성 시 최적화 원칙을 잘 이해하고, 주기적으로 쿼리를 개선하는 것이 필요하다.

---

# 요약

1. **인덱스 활용**: 필요한 컬럼에 적절한 인덱스를 생성하여 쿼리 성능을 높인다.
2. **불필요한 열 제거**: `SELECT *` 대신 필요한 열만 선택해 불필요한 데이터를 처리하지 않도록 한다.
3. **조인 순서 최적화**: 작은 테이블부터 먼저 처리하는 등 조인 순서를 효율적으로 결정한다.
4. **서브쿼리 대신 JOIN 사용**: 중첩된 서브쿼리 대신 조인을 활용하여 성능을 개선한다.
5. **EXISTS 사용**: 조인보다 `EXISTS`를 사용해 성능을 높이는 경우가 있다.
6. **LIMIT 사용**: 대규모 데이터를 다룰 때는 필요한 만큼의 데이터만 조회하도록 `LIMIT`을 사용한다.
7. **실행 계획 분석**: 실행 계획을 통해 데이터베이스가 쿼리를 어떻게 처리하는지 확인하고, 최적화할 수 있는 부분을 찾아낸다.
8. **통계 정보 관리**: 데이터베이스의 통계를 주기적으로 업데이트하여 최적화된 실행 계획을 유지한다.
9. **파티셔닝**: 큰 테이블을 파티셔닝하여 검색 성능을 향상시킨다.