# EntityManager의 flush()와 clear()

- JPA에서 `EntityManager`의 `flush()`와 `clear()` 메서드는 영속성 컨텍스트(Persistence Context)를 관리하는 중요한 역할을 수행함.
- `flush()`는 **영속성 컨텍스트에 있는 변경 사항을 데이터베이스에 반영**하는 역할
- `clear()`는 **영속성 컨텍스트를 비워 영속성 컨텍스트에 관리되는 모든 엔티티를 준영속 상태로 변경**하는 역할을 함.

---

# **`flush()`**

## **역할**:

- `flush()` 메서드는 **영속성 컨텍스트에 저장된 변경 사항을 데이터베이스에 반영**하는 역할을 함.
- 즉, **영속성 컨텍스트에 있는 엔티티들의 변경 사항(INSERT, UPDATE, DELETE)이 즉시 데이터베이스에 적용**되도록 함.
- 하지만 트랜잭션이 종료되지는 않으며, 트랜잭션은 계속 유지됨.

## **동작 방식**:

- 영속성 컨텍스트는 엔티티의 변경 사항을 **메모리**에서 관리하다가, 트랜잭션이 커밋될 때 데이터베이스에 자동으로 반영함.
- 하지만 `flush()` 메서드를 호출하면 **트랜잭션이 커밋되기 전에** 변경 사항을 **즉시 데이터베이스에 반영**할 수 있음.
- `flush()`가 호출되면 **SQL 쿼리**가 즉시 데이터베이스로 전송되어, **INSERT**, **UPDATE**, **DELETE**가 수행됨.
- 그러나 **영속성 컨텍스트는 유지**되고, 트랜잭션도 종료되지 않음.

## **사용 시점**:

- **데이터베이스에 변경 사항을 강제로 반영해야 할 때**:
    - 트랜잭션 중간에 변경 사항을 데이터베이스에 반영해야 하는 경우 사용. 예를 들어, 다른 데이터베이스 쿼리나 로직에서 변경된 데이터가 필요할 때.
- **벌크 연산 전**:
    - 벌크 연산(예: `DELETE`, `UPDATE`)을 수행하기 전에 `flush()`를 사용하여, 영속성 컨텍스트의 상태와 데이터베이스의 상태를 일치시켜 **일관성 문제를 방지**함.

## **예시**

```java
EntityManager em = entityManagerFactory.createEntityManager();
em.getTransaction().begin();

User user = new User();
user.setName("John Doe");

em.persist(user);  // 영속성 컨텍스트에 저장

em.flush();  // 데이터베이스에 즉시 INSERT 쿼리 실행

// 트랜잭션은 아직 유지됨, 이후의 작업에서 user가 데이터베이스에 반영된 상태로 사용됨

em.getTransaction().commit();
```

## **설명**:

- `flush()`를 호출하면, 트랜잭션이 끝나기 전에 영속성 컨텍스트에 있는 `user` 객체의 변경 사항이 **즉시 데이터베이스에 반영**됨.
- 이후 트랜잭션이 커밋되더라도, `flush()`에 의해 변경 사항이 미리 데이터베이스에 반영됨.

---

# **`clear()`**

## **역할**:

- `clear()` 메서드는 **영속성 컨텍스트를 완전히 비우는 역할**을 함.
- **영속성 컨텍스트에서 관리되고 있는 모든 엔티티를 준영속 상태**로 전환하여, 더 이상 해당 엔티티들은 영속성 컨텍스트에서 관리되지 않음.
- 이로 인해 **영속성 컨텍스트에서 관리되던 변경 사항이 모두 사라짐**.

## **동작 방식**:

- `clear()`를 호출하면 **영속성 컨텍스트 내에 있던 모든 엔티티가 영속 상태에서 준영속 상태로 변경**됨.
- 이후 이 엔티티들은 더 이상 **영속성 컨텍스트에 의해 관리되지 않으며**, 변경 사항이 발생해도 자동으로 데이터베이스에 반영되지 않음.
- 다시 영속 상태로 만들려면, `merge()` 메서드를 사용해야 함.

## **사용 시점**:

- **메모리 관리가 필요할 때**:
    - 대량의 데이터를 처리하거나, 트랜잭션 중간에 불필요한 엔티티를 메모리에서 제거하여 **영속성 컨텍스트의 메모리 사용량을 줄이고자 할 때**.
- **영속성 컨텍스트를 재설정해야 할 때**:
    - 기존의 영속성 컨텍스트 상태를 초기화하고, 새로운 상태로 시작해야 할 때.
- **벌크 연산 후**:
    - 벌크 연산 후 영속성 컨텍스트와 데이터베이스 상태가 일치하지 않을 수 있으므로, 벌크 연산 후 `clear()`를 호출하여 **캐시를 비워 상태를 일관성 있게 유지**.

## **예시**

```java
EntityManager em = entityManagerFactory.createEntityManager();
em.getTransaction().begin();

User user = em.find(User.class, 1L);  // 영속성 컨텍스트에 저장

em.clear();  // 영속성 컨텍스트를 비워, user는 준영속 상태로 전환

user.setName("New Name");  // 변경되지만 데이터베이스에 반영되지 않음

em.getTransaction().commit();
```

## **설명**:

- `clear()`를 호출한 후, `user`는 **준영속 상태**가 되어 더 이상 영속성 컨텍스트에서 관리되지 않음.
- `setName("New Name")`으로 변경했지만, 이 변경 사항은 **데이터베이스에 반영되지 않음**.
- 엔티티가 준영속 상태이기 때문에 Dirty Checking이 적용되지 않음.

# **flush()와 clear()를 함께 사용하는 경우**

- `flush()`와 `clear()`는 종종 **대량의 데이터 처리**나 **벌크 연산**에서 함께 사용됨.
- 대량의 데이터가 영속성 컨텍스트에 쌓이면 **메모리 사용량이 증가**하므로, `flush()`로 변경 사항을 **데이터베이스에 반영**한 후, `clear()`로 **영속성 컨텍스트를 비워** 메모리를 확보하는 방식
- **대량 데이터 처리에서의 사용 예시**

    ```java
    for (int i = 0; i < 1000; i++) {
        User user = new User();
        user.setName("User" + i);
    
        em.persist(user);
    
        if (i % 100 == 0) {
            em.flush();  // 100개의 엔티티마다 데이터베이스에 반영
            em.clear();  // 영속성 컨텍스트를 비워 메모리 확보
        }
    }
    ```

- **설명**:
    - 100개의 엔티티를 영속성 컨텍스트에 쌓을 때마다 `flush()`를 호출해 **데이터베이스에 반영**하고, `clear()`를 호출해 **영속성 컨텍스트를 비움**으로써 메모리 사용량을 줄임.

---

# 비교

| **특징** | **`flush()`** | **`clear()`** |
| --- | --- | --- |
| **역할** | 영속성 컨텍스트에 있는 변경 사항을 **즉시 데이터베이스에 반영** | 영속성 컨텍스트를 **완전히 비움** |
| **영속성 컨텍스트 상태** | **유지**됨 | **비워짐**, 모든 엔티티가 **준영속 상태**로 변경 |
| **트랜잭션 종료 여부** | **트랜잭션은 종료되지 않음**, 유지됨 | 트랜잭션 유지, 하지만 더 이상 엔티티가 영속성 컨텍스트에서 관리되지 않음 |
| **변경 사항 반영 여부** | 영속성 컨텍스트의 변경 사항이 **즉시 반영** | 변경 사항이 반영되지 않음, 영속성 컨텍스트에서 모든 엔티티가 제거됨 |
| **사용 시점** | 트랜잭션 중간에 변경 사항을 **강제로 반영**해야 할 때 | 영속성 컨텍스트를 **초기화**하거나 **메모리 절약**이 필요할 때 |

---

# 정리

- **`flush()`**: 영속성 컨텍스트에 있는 **변경 사항을 데이터베이스에 즉시 반영**하지만, 트랜잭션은 유지됨. 트랜잭션 중간에 **데이터베이스 반영이 필요할 때** 사용.
- **`clear()`**: **영속성 컨텍스트를 완전히 비워** 관리되던 모든 엔티티를 준영속 상태로 전환. **대량의 데이터를 처리**하거나 **영속성 컨텍스트를 초기화**할 때 사용.
- `flush()`는 **변경 사항의 즉시 반영**, `clear()`는 **영속성 컨텍스트 초기화**를 위해 사용되며, 함께 사용하면 **메모리 관리**와 **성능 최적화**에 유용함.