# JPA에서 DB의 동기화 타이밍을 관리하는 법

- JPA에서 데이터베이스와 **동기화 타이밍을 관리**하는 방법은 영속성 컨텍스트(Persistence Context와 **플러시(Flush) 전략**을 통해 제어할 수 있음
- JPA는 기본적으로 **트랜잭션이 커밋될 때** 데이터베이스와 동기화되지만, 동기화 시점을 **더 세밀하게 제어**하기 위해 다양한 방법이 제공됨

---

# **동기화 타이밍을 제어하는 방법**

## **플러시 모드(Flush Mode) 설정**을 통한 제어

- **플러시 모드**는 영속성 컨텍스트에서 **데이터베이스와 동기화하는 시점**을 제어하는 방식

### JPA는 두 가지 **플러시 모드**를 지원

- **`FlushModeType.AUTO`** (기본 설정): 트랜잭션이 커밋되기 직전에, 또는 특정 쿼리가 실행되기 전에 자동으로 동기화
- **`FlushModeType.COMMIT`**: 트랜잭션이 **커밋될 때**만 동기화

### **플러시 모드 설정 방법**

- 플러시 모드는 **`EntityManager`** 또는 **`Query`** 단위에서 설정할 수 있다

    ```java
    // EntityManager 단위에서 플러시 모드 설정
    EntityManager em = entityManagerFactory.createEntityManager();
    em.setFlushMode(FlushModeType.COMMIT);  // 트랜잭션 커밋 시에만 동기화
    
    // Query 단위에서 플러시 모드 설정
    Query query = em.createQuery("SELECT u FROM User u WHERE u.name = :name");
    query.setFlushMode(FlushModeType.COMMIT);
    ```

- **`FlushModeType.AUTO`**:
    - 변경 사항이 있을 때 **JPQL 쿼리가 실행되기 전에 자동으로 플러시**.
    - 예를 들어, JPQL `SELECT` 쿼리를 실행할 때 **이전에 발생한 엔티티 변경 사항이 데이터베이스에 반영**된 후 쿼리가 실행
- **`FlushModeType.COMMIT`**:
    - **트랜잭션 커밋 시점**에만 플러시. 따라서 **SELECT 쿼리 전에 변경 사항이 반영되지 않음**.

### **플러시 모드 설정 예시**

```java
// AUTO 플러시 모드 (기본값)
em.setFlushMode(FlushModeType.AUTO);
User user = new User();
user.setName("John");
em.persist(user);  // 아직 DB에는 반영되지 않음

// SELECT 쿼리 실행 시점에 플러시가 발생하여 변경 사항이 반영됨
List<User> users = em.createQuery("SELECT u FROM User u").getResultList();
```

---

## **명시적 `flush()` 메서드 호출**을 통한 제어

- 플러시를 **명시적으로 제어**하기 위해 `flush()` 메서드를 호출하여 **영속성 컨텍스트의 변경 사항을 데이터베이스에 강제로 반영**할 수 있음
- 이 방법을 사용하면 트랜잭션 커밋 전에 데이터를 **중간에 강제로 데이터베이스에 반영**할 수 있음

### **명시적 `flush()` 호출 예시**

```java
em.getTransaction().begin();

User user = new User();
user.setName("John");
em.persist(user);  // 영속성 컨텍스트에만 반영됨 (아직 DB에 반영되지 않음)

em.flush();  // 강제로 DB에 반영 (INSERT 쿼리 발생)

// 트랜잭션 유지 상태에서 다른 작업 수행
em.getTransaction().commit();  // 최종적으로 트랜잭션 커밋
```

- `flush()`를 호출하면 영속성 컨텍스트의 변경 사항이 즉시 **데이터베이스에 반영**
- 하지만 트랜잭션은 **유지**되며, 이후 작업을 추가로 처리할 수 있다.

### **언제 `flush()`를 사용해야 할까?**

- **중간에 데이터베이스 반영이 필요한 경우**:
    - 예를 들어, 일부 엔티티의 변경 사항을 즉시 데이터베이스에 반영한 후, 그 결과를 기반으로 다른 작업을 해야 하는 경우 `flush()`를 사용
- **벌크 연산 전에**:
    - 벌크 연산을 수행하기 전에 `flush()`를 호출하여, **영속성 컨텍스트와 데이터베이스 상태를 동기화**할 수 있다

---

## **트랜잭션 커밋을 통한 자동 동기화**

- JPA는 기본적으로 **트랜잭션이 커밋될 때** 영속성 컨텍스트에 있는 모든 변경 사항을 데이터베이스에 자동으로 동기화
- 이는 가장 일반적인 동기화 방식으로, 플러시 모드가 `AUTO`로 설정된 경우에도 적용

### **자동 동기화 동작**

```java
em.getTransaction().begin();

User user = new User();
user.setName("John");
em.persist(user);  // 영속성 컨텍스트에 저장됨

em.getTransaction().commit();  // 커밋 시점에 DB에 INSERT 쿼리 발생
```

- `persist()` 호출 시 `user` 엔티티는 영속성 컨텍스트에 저장되지만, **즉시 데이터베이스에 반영되지 않음**.
- 트랜잭션이 커밋될 때, JPA는 **영속성 컨텍스트의 변경 사항을 데이터베이스에 자동으로 동기화**

---

# **JPA 동기화 관련 유의사항**

## **플러시가 빈번하게 발생할 수 있음**:

- `FlushModeType.AUTO`로 설정된 경우, **JPQL 쿼리나 네이티브 쿼리 실행 전에 플러시가 발생**할 수 있음
- 이는 성능에 영향을 미칠 수 있으므로 **쿼리 실행 전에 불필요한 변경 사항이 있는지 확인**하는 것이 중요

## **`flush()` 호출 시 주의**:

- **`flush()`는 트랜잭션 커밋을 의미하지 않음**.
- 즉, 데이터베이스에 반영되었더라도 트랜잭션이 롤백되면 변경 사항은 모두 취소

## **벌크 연산 전/후 플러시 및 클리어**:

- JPA는 벌크 연산(`UPDATE`, `DELETE`)이 실행되면 **영속성 컨텍스트를 무시하고 직접 SQL을 실행**
- 이때 **플러시하지 않으면 데이터베이스와 영속성 컨텍스트가 불일치**할 수 있으므로, 벌크 연산 전에 `flush()`를 호출하는 것이 좋다
- 벌크 연산 후에는 **영속성 컨텍스트와 데이터베이스의 상태를 맞추기 위해 `clear()`를 호출**하여 영속성 컨텍스트를 초기화하는 것도 좋은 방법

---

# **정리**

- **플러시 모드(Flush Mode)**:
    - `FlushModeType.AUTO`: **트랜잭션 커밋 또는 JPQL 쿼리 실행 시점**에 동기화.
    - `FlushModeType.COMMIT`: **트랜잭션이 커밋될 때만 동기화**.
- **명시적 `flush()` 호출**:
    - 변경 사항을 **강제로 데이터베이스에 반영**하고 싶을 때 사용. 트랜잭션 중간에 데이터베이스와 동기화해야 할 경우 유용.
- **트랜잭션 커밋 시 자동 동기화**:
    - 기본적으로 JPA는 **트랜잭션이 커밋될 때** 영속성 컨텍스트의 변경 사항을 데이터베이스에 자동으로 반영.
- 이러한 방법을 통해 JPA의 동기화 시점을 세밀하게 제어할 수 있으며, **효율적인 데이터 관리**와 **성능 최적화**를 도모할 수 있습니다.